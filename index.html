<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>2.5D Isometric City — Full</title>

<style>
  :root{
    --ui-bg: rgba(0,0,0,0.55);
    --btn-bg: #1e3;
    --btn-sel: #28a;
    --text: #eaf6ff;
  }
  html,body{height:100%;margin:0;background:#06101e;font-family:system-ui,Segoe UI,Roboto,Arial;}
  #ui{
    position:fixed; left:12px; top:12px; z-index:40;
    background:var(--ui-bg); color:var(--text); padding:12px; border-radius:10px;
    backdrop-filter:blur(6px); max-width:360px;
  }
  #toolbar{display:flex;flex-wrap:wrap;gap:6px;max-width:340px; margin-top:8px;}
  .tool{padding:6px 10px;border-radius:6px;background:#233;color:white;cursor:pointer;border:1px solid #456;font-size:13px;}
  .tool.sel{background:var(--btn-sel);}
  #info{margin-top:10px;font-size:13px;color:#cfe;}
  #canvas-wrap{position:fixed;inset:0;z-index:1}
  canvas{display:block;width:100vw;height:100vh}
  #footerNote{position:fixed;left:12px;bottom:12px;color:#9fb;font-size:12px;background:#0004;padding:6px 8px;border-radius:6px}
</style>
</head>

<body>

<div id="ui">
  <div style="font-weight:700">2.5D Isometric City — Demo</div>
  <div style="font-size:13px;margin-top:6px">Auto-loaded assets from <code>/tiles/</code> and <code>/buildings/</code></div>
  <div id="toolbar"></div>
  <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
    <button id="btnTick" class="tool small">Tick</button>
    <button id="btnSave" class="tool small">Save</button>
    <button id="btnLoad" class="tool small">Load</button>
    <button id="btnReset" class="tool small">Reset</button>
  </div>
  <div id="info">
    Money: <span id="money">200</span> &nbsp; • &nbsp; Pop: <span id="pop">0</span> &nbsp; • &nbsp; Time: <span id="time">0</span>
  </div>
</div>

<div id="canvas-wrap"></div>
<div id="footerNote">Assets folder: <code>/tiles</code> and <code>/buildings</code></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script type="module">

/* ============================================================
   CONFIG
============================================================ */
const MAP_W = 20, MAP_H = 20;
const TILE_W = 1.28;
let money = 200, pop = 0, timeTick = 0;
let tool = "grass";

/* ============================================================
   LOAD ASSETS
============================================================ */
async function loadTileAssets(){
  const res = await fetch("tiles/assets.json");
  const data = await res.json();
  const loader = new THREE.TextureLoader();
  const out = {};
  for(const f of data.tiles){
    const name = f.replace(".png","");
    out[name] = loader.load("tiles/" + f);
  }
  return out;
}

async function loadBuildingAssets(){
  const res = await fetch("buildings/assets.json");
  const data = await res.json();
  const loader = new THREE.TextureLoader();
  const out = {};
  for(const f of data.buildings){
    const name = f.replace(".png","");
    out[name] = loader.load("buildings/" + f);
  }
  return out;
}

/* ============================================================
   THREE.JS
============================================================ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x06101e);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.getElementById("canvas-wrap").appendChild(renderer.domElement);

const aspect = window.innerWidth/window.innerHeight;
const camSize = 16;
const camera = new THREE.OrthographicCamera(
  camSize*aspect/-2, camSize*aspect/2,
  camSize/2, camSize/-2,
  -200, 200
);

let isoYaw = 45*Math.PI/180;
let isoPitch = -35*Math.PI/180;
let camRadius = 20;

function updateCamera(){
  const x = camRadius*Math.cos(isoPitch)*Math.cos(isoYaw);
  const y = camRadius*Math.sin(isoPitch)+6;
  const z = camRadius*Math.cos(isoPitch)*Math.sin(isoYaw);
  camera.position.set(x,y,z);
  camera.lookAt(0,0,0);
  camera.updateProjectionMatrix();
}
updateCamera();

scene.add(new THREE.AmbientLight(0xffffff,0.45));
const dir = new THREE.DirectionalLight(0xffffff,0.9);
dir.position.set(10,20,10);
scene.add(dir);

/* ============================================================
   MAP + SPRITES
============================================================ */
const tileGroup = new THREE.Group();
const spriteGroup = new THREE.Group();
scene.add(tileGroup, spriteGroup);

const planeGeo = new THREE.PlaneGeometry(1, 0.5);
planeGeo.rotateX(-Math.PI/2);

const map = [];

function gridToWorld(x,y){
  const sx = -(MAP_W/2)*TILE_W + TILE_W/2;
  const sz = -(MAP_H/2)*TILE_W + TILE_W/2;
  return { x: sx + x*TILE_W, z: sz + y*TILE_W };
}

function createTileMesh(x,y,tex){
  const mat = new THREE.MeshBasicMaterial({ 
    map: tex,
    transparent:true,
    depthWrite:false,
    depthTest:false 
  });

  // จัด texture ให้อยู่กลาง tile
  tex.center.set(0.5,0.5);
  tex.rotation = 0;

  const mesh = new THREE.Mesh(planeGeo,mat);
  const p = gridToWorld(x,y);
  mesh.position.set(p.x,0,p.z);
  mesh.renderOrder = y;  // เรียงตามแถว

  return mesh;
}

function initMap(defaultTile){
  tileGroup.clear();
  spriteGroup.clear();
  for(let y=0;y<MAP_H;y++){
    map[y]=[];
    for(let x=0;x<MAP_W;x++){
      const mesh = createTileMesh(x,y,TILE_TEX[defaultTile]);
      tileGroup.add(mesh);
      map[y][x]={ tile:defaultTile, mesh, sprite:null };
    }
  }
}

function makeSprite(tex){
  const m = new THREE.SpriteMaterial({map:tex,transparent:true});
  const s = new THREE.Sprite(m);
  s.scale.set(0.6,0.6,1);
  return s;
}

function placeBuilding(x,y,name){
  if(!SPRITE_TEX[name]) return;
  const sp = makeSprite(SPRITE_TEX[name]);
  const p = gridToWorld(x,y);
  sp.position.set(p.x,0.8,p.z);
  spriteGroup.add(sp);
  map[y][x].sprite = sp;
  
}

/* ============================================================
   TILE SETTER
============================================================ */
function setTile(x,y,name){
  map[y][x].mesh.material.map = TILE_TEX[name];
  map[y][x].mesh.material.needsUpdate = true;
  map[y][x].tile = name;
}

/* ============================================================
   RAYCAST
============================================================ */
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function getGridFromPointer(mx,my){
  const rect = renderer.domElement.getBoundingClientRect();
  pointer.x = ((mx-rect.left)/rect.width)*2-1;
  pointer.y = -((my-rect.top)/rect.height)*2+1;
  raycaster.setFromCamera(pointer,camera);

  const plane = new THREE.Plane(new THREE.Vector3(0,1,0),0);
  const hit = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane,hit);

  const sx = -(MAP_W/2)*TILE_W + TILE_W/2;
  const sz = -(MAP_H/2)*TILE_W + TILE_W/2;

  const fx = (hit.x-sx)/TILE_W;
  const fz = (hit.z-sz)/TILE_W;

  const x = Math.floor(fx+0.5);
  const y = Math.floor(fz+0.5);

  if(x<0||y<0||x>=MAP_W||y>=MAP_H) return null;
  return {x,y};
}

/* ============================================================
   INPUT
============================================================ */
renderer.domElement.addEventListener("pointerdown", e=>{
  const g = getGridFromPointer(e.clientX,e.clientY);
  if(!g) return;
  if(TILE_TEX[tool]) setTile(g.x,g.y,tool);
  if(SPRITE_TEX[tool]) placeBuilding(g.x,g.y,tool);
});

/* ============================================================
   TOOLBAR
============================================================ */
function buildToolbar(){
  const bar = document.getElementById("toolbar");
  bar.innerHTML="";

  for(const t in TILE_TEX){
    const btn=document.createElement("div");
    btn.className="tool";
    btn.textContent=t;
    btn.onclick=()=>selectTool(t,btn);
    bar.appendChild(btn);
  }

  for(const s in SPRITE_TEX){
    const btn=document.createElement("div");
    btn.className="tool";
    btn.textContent=s;
    btn.onclick=()=>selectTool(s,btn);
    bar.appendChild(btn);
  }

  selectTool(Object.keys(TILE_TEX)[0]);
}

function selectTool(name,btn){
  tool=name;
  document.querySelectorAll(".tool").forEach(b=>b.classList.remove("sel"));
  if(btn) btn.classList.add("sel");
}

/* ============================================================
   ANIMATION
============================================================ */
function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene,camera);
}
animate();

/* ============================================================
   MAIN – LOAD ASSETS → INIT MAP → UI
============================================================ */
const TILE_TEX = await loadTileAssets();
const SPRITE_TEX = await loadBuildingAssets();

initMap("grass");
buildToolbar();

initMap("grass");
buildToolbar();

/* ========== วางโค้ดกริดตรงนี้ ========== */

// --------- Grid overlay (isometric diamond per tile) ----------
const gridGroup = new THREE.Group();
scene.add(gridGroup);

const GRID_COLOR = 0x88ccff;
const GRID_OPACITY = 0.7;
let showGrid = true;

function makeTileOutline(x, y) {
  const half = TILE_W / 2;
  const c = gridToWorld(x, y);

  const p0 = new THREE.Vector3(c.x, 0.01, c.z - half);
  const p1 = new THREE.Vector3(c.x + half, 0.01, c.z);
  const p2 = new THREE.Vector3(c.x, 0.01, c.z + half);
  const p3 = new THREE.Vector3(c.x - half, 0.01, c.z);

  const geom = new THREE.BufferGeometry().setFromPoints([p0,p1,p2,p3,p0]);
  const mat = new THREE.LineBasicMaterial({
    color: GRID_COLOR,
    transparent:true,
    opacity:GRID_OPACITY
  });

  const line = new THREE.Line(geom, mat);
  line.renderOrder = 1000;
  return line;
}

function buildGrid(){
  gridGroup.clear();
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      gridGroup.add(makeTileOutline(x,y));
    }
  }
  gridGroup.visible = showGrid;
}

function toggleGrid(){
  showGrid = !showGrid;
  gridGroup.visible = showGrid;
}

(function createGridButton(){
  const bar = document.getElementById('toolbar');
  const btn = document.createElement('div');
  btn.className = 'tool';
  btn.textContent = 'grid';
  btn.onclick = () => { toggleGrid(); btn.classList.toggle('sel'); };
  bar.appendChild(btn);
})();

buildGrid();

/* ========== จบโค้ดกริด ========== */

</script>
</body>
</html>
